import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split
import os

# ================= CONFIGURATION =================
TIME_STEPS = 200    # 2 seconds @ 100Hz
STEP_OVERLAP = 100  # 50% overlap
EPOCHS = 25
BATCH_SIZE = 64
# =================================================

def create_windows(data, time_steps, step):
    xs, ys = [], []
    for i in range(0, len(data) - time_steps, step):
        v = data.iloc[i:(i + time_steps)].values
        features = v[:, :6] 
        # Label is the 7th column (index 6)
        label = float(max(set(v[:, 6]), key=list(v[:, 6]).count))
        xs.append(features)
        ys.append(label)
    return np.array(xs), np.array(ys).reshape(-1, 1)

def save_c_header(tflite_model_content, variable_name="fall_model"):
    # Convert the binary content to a hex string array
    hex_array = [f"0x{b:02x}" for b in tflite_model_content]
    
    # Format as C code
    c_str = f"// Auto-generated by train_local.py\n"
    c_str += f"const unsigned char {variable_name}[] = {{\n  "
    c_str += ", ".join(hex_array)
    c_str += f"\n}};\n\nconst int {variable_name}_len = {len(tflite_model_content)};"
    
    # Save to file
    with open(f"{variable_name}.h", "w") as f:
        f.write(c_str)
    print(f"\n[SUCCESS] Generated C-Header file: {variable_name}.h")

# --- 1. LOAD DATA ---
print("--- 1. LOADING DATA ---")
df_falls = pd.read_csv("processed_data/training_falls.csv")
df_adls = pd.read_csv("processed_data/training_adls.csv")

# Balance data (Optional: Limit ADLs to 3x Falls to prevent bias)
if len(df_adls) > len(df_falls) * 3:
    print(f"Trimming ADLs to {len(df_falls)*3} rows for balance...")
    df_adls = df_adls.sample(n=len(df_falls) * 3, random_state=42)

print(f"Falls: {len(df_falls)} | ADLs: {len(df_adls)}")

# --- 2. PREPARE WINDOWS ---
print("--- 2. CREATING WINDOWS ---")
X_falls, y_falls = create_windows(df_falls, TIME_STEPS, STEP_OVERLAP)
X_adls, y_adls = create_windows(df_adls, TIME_STEPS, STEP_OVERLAP)

X = np.concatenate([X_falls, X_adls])
y = np.concatenate([y_falls, y_adls])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
print(f"Training on {X_train.shape[0]} windows...")

# --- 3. TRAIN MODEL (1D CNN) ---
print("--- 3. TRAINING MODEL ---")
model = models.Sequential([
    layers.Input(shape=(TIME_STEPS, 6)),
    layers.Conv1D(16, 3, activation='relu'),
    layers.MaxPooling1D(2),
    layers.Dropout(0.2),
    layers.Conv1D(32, 3, activation='relu'),
    layers.MaxPooling1D(2),
    layers.Flatten(),
    layers.Dense(32, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=EPOCHS, batch_size=BATCH_SIZE, validation_data=(X_test, y_test))

# --- 4. CONVERT DIRECTLY TO C HEADER ---
print("--- 4. CONVERTING TO C HEADER ---")

# Convert Keras -> TFLite (In Memory Only)
converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
tflite_buffer = converter.convert() # This is now just a byte variable, not a file

# Save directly to .h
save_c_header(tflite_buffer, "fall_model")

print("\nDONE! 'fall_model.h' is ready.") 